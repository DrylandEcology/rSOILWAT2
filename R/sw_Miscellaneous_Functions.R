#' Calculate variables required to estimate percent C4 species in North America
#'
#' @return A named numeric vector of length 6.
#' @references Teeri J.A., Stowe L.G. (1976) Climatic patterns and the
#'   distribution of C4 grasses in North America. Oecologia, 23, 1-12.
#'
#' @export
sw_dailyC4_TempVar <- function(dailyTempMin, dailyTempMean, simTime2) {

  temp7 <- simTime2$month_ForEachUsedDay_NSadj == 7
  Month7th_MinTemp_C <- tapply(dailyTempMin[temp7],
    simTime2$year_ForEachUsedDay_NSadj[temp7], min)
  FrostFree_Days <- tapply(dailyTempMin, simTime2$year_ForEachUsedDay_NSadj,
    function(x) {
      temp <- rle(x > 0)
      if (any(temp$values)) max(temp$lengths[temp$values], na.rm = TRUE) else 0
    })

  # 18.333 C = 65 F with (65 - 32) * 5 / 9
  temp_base65F <- dailyTempMean - 18.333
  temp_base65F[temp_base65F < 0] <- 0
  DegreeDaysAbove65F_DaysC <- tapply(temp_base65F,
    simTime2$year_ForEachUsedDay_NSadj, sum)

  # if southern Hemisphere, then 7th month of last year is not included
  nyrs <- seq_along(Month7th_MinTemp_C)
  temp <- cbind(Month7th_MinTemp_C[nyrs], FrostFree_Days[nyrs],
    DegreeDaysAbove65F_DaysC[nyrs])
  res <- c(apply(temp, 2, mean), apply(temp, 2, sd))
  temp <- c("Month7th_NSadj_MinTemp_C",
    "LengthFreezeFreeGrowingPeriod_NSadj_Days",
    "DegreeDaysAbove65F_NSadj_DaysC")
  names(res) <- c(temp, paste0(temp, ".sd"))

  res
}

#' Calculate climate variables required to estimate percent cheatgrass cover
#' in North America
#'
#' @section Note: This function does not correct for northern/southern
#'   hemisphere.
#'
#' @param monthlyPPT_cm A numeric matrix of monthly precipitation values in
#'   centimeter. There are 12 rows, one for each month of the year;
#'   and there is one column for each year.
#' @param monthlyTempMean_C A numeric matrix of monthly mean temperature values
#'   in degree Celsius. There are 12 rows, one for each month of the year;
#'   and there is one column for each year.
#' @param monthlyTempMin_C A numeric matrix of monthly minimum temperature
#'   value sin degree Celsius. There are 12 rows, one for each month of the
#'   year; and there is one column for each year.
#'
#' @return A named numeric vector of length 6 with mean and standard deviation
#'   for \var{Month7th_PPT_mm}, \var{MeanTemp_ofDriestQuarter_C}, and
#'   \var{MinTemp_of2ndMonth_C}.
#'
#' @references Brummer, T. J., K. T. Taylor, J. Rotella, B. D. Maxwell,
#'   L. J. Rew, and M. Lavin. 2016. Drivers of Bromus tectorum Abundance in
#'   the Western North American Sagebrush Steppe. Ecosystems 19:986-1000.
#'
#' @export
sw_Cheatgrass_ClimVar <- function(monthlyPPT_cm,
  monthlyTempMean_C = NULL, monthlyTempMin_C = NULL) {

  # Mean precipitation sum of seventh month of the season (i.e.,
  # July in northern hemisphere)
  Month7th_PPT_mm <- 10 * monthlyPPT_cm[7, ]
  nyrs <- seq_along(Month7th_PPT_mm)

  # Mean temperature of driest quarter (Bioclim variable 9)
  # see \code{link[dismo]{biovars}}
  if (!is.null(monthlyTempMean_C)) {
    wet <- t(apply(monthlyPPT_cm, 2, rSW2utils::moving_function,
      k = 3, win_fun = sum, na.rm = TRUE, circular = TRUE
    ))
    tmp <- t(apply(monthlyTempMean_C, 2, rSW2utils::moving_function,
      k = 3, win_fun = mean, na.rm = TRUE, circular = TRUE
    ))
    dryqrt <- cbind(
      seq_len(ncol(monthlyPPT_cm)),
      as.integer(apply(wet, 1, which.min))
    )
    MeanTemp_ofDriestQuarter_C <- tmp[dryqrt]

  } else {
    MeanTemp_ofDriestQuarter_C <- rep(NA, length(Month7th_PPT_mm))
  }

  # Minimum February temperature
  if (!is.null(monthlyTempMin_C)) {
    MinTemp_of2ndMonth_C <- monthlyTempMin_C[2, , ]
  } else {
    MinTemp_of2ndMonth_C <- rep(NA, length(Month7th_PPT_mm))
  }


  # Aggregate
  temp <- cbind(
    Month7th_PPT_mm[nyrs],
    MeanTemp_ofDriestQuarter_C[nyrs],
    MinTemp_of2ndMonth_C[nyrs]
  )

  res <- c(apply(temp, 2, mean), apply(temp, 2, sd))
  temp <- c("Month7th_PPT_mm", "MeanTemp_ofDriestQuarter_C",
    "MinTemp_of2ndMonth_C")
  names(res) <- c(temp, paste0(temp, "_SD"))

  res
}

#' Calculate climate variables from daily weather
#'
#' @param weatherList A list. Each element is an object of class
#'   \code{\link[rSOILWAT2:swWeatherData-class]{rSOILWAT2::swWeatherData}}
#'   containing daily weather data of a specific year.
#' @param year.start An integer value. The first year of the range of years for
#'   which climate variables should be calculated.
#' @param year.end An integer value. The last year of the range of years for
#'   which climate variables should be calculated.
#' @param do_C4vars A logical value. If \code{TRUE} then additional output is
#'   returned.
#' @param do_Cheatgrass_ClimVars A logical value. If \code{TRUE} then additional
#'   output is returned.
#' @param simTime2 A list with two named elements. The elements are numeric
#'   vectors \var{month_ForEachUsedDay_NSadj} and
#'   \var{year_ForEachUsedDay_NSadj}; they are calculated internally
#'   if \code{NULL}; alternatively, they can be generated by a call to the
#'   function \code{\link[rSW2data]{simTiming_ForEachUsedTimeUnit}}.
#'   They are only used if \code{isTRUE(do_C4vars)}.
#' @param latitude A numeric value. The latitude in degree of the site. Used
#'   to adjust seasons between northern/southern hemisphere only if
#'   \code{isTRUE(do_C4vars)} and \code{simTime2} has to be re-calculated.
#'
#' @return A list with named elements \itemize{
#'   \item{\var{\dQuote{meanMonthlyTempC}}} {A numeric vector of length 12.
#'    Mean monthly mean daily air temperature in degree Celsius.}
#'   \item{\var{\dQuote{minMonthlyTempC}}} {A numeric vector of length 12.
#'     Mean monthly minimum daily air temperature in degree Celsius.}
#'   \item{\var{\dQuote{maxMonthlyTempC}}} {A numeric vector of length 12.
#'     Mean monthly maximum daily air temperature in degree Celsius.}
#'   \item{\var{\dQuote{meanMonthlyPPTcm}}} {A numeric vector of length 12.
#'     Mean monthly precipitation in centimeters.}
#'   \item{\var{\dQuote{MAP_cm}}} {A numeric value. Mean annual precipitation
#'     in centimeters.}
#'   \item{\var{\dQuote{MAT_C}}} {A numeric value. Mean annual air temperature
#'     in degree Celsius.}
#'   \item{\var{\dQuote{dailyTempMin}}} {A numeric vector. If
#'     \code{isTRUE(do_C4vars)}, then minimum daily air temperature in degree
#'     Celsius for each day of time period between \code{year.start} and
#'     \code{year.end}. If \code{!isTRUE(do_C4vars)}, then \code{NA}.}
#'   \item{\var{\dQuote{dailyTempMean}}} {A numeric vector. Similar as for
#'     \code{dailyTempMin} but for mean daily air temperature.}
#'   \item{\var{\dQuote{dailyC4vars}}} {If \code{isTRUE(do_C4vars)}, then a
#'     named numeric vector containing the output of
#'     \code{\link{sw_dailyC4_TempVar}}, else \code{NA}.}
#'   \item{\var{\dQuote{monthlyCheatgrass_ClimVars}}} {
#'     If \code{isTRUE(do_Cheatgrass_ClimVars)}, then a named numeric vector
#'     containing the output of \code{\link{sw_Cheatgrass_ClimVar}},
#'     else \code{NA}.}
#' }
#'
#' @examples
#' ## Load weather dataset from rSOILWAT2
#' utils::data("weatherData", package = "rSOILWAT2")
#' clim1 <- calc_SiteClimate(weatherList = weatherData)
#' clim2 <- calc_SiteClimate(weatherList = weatherData, do_C4vars = TRUE)
#' clim3 <- calc_SiteClimate(weatherList = weatherData,
#'   do_Cheatgrass_ClimVars = TRUE)
#'
#' @export
calc_SiteClimate <- function(weatherList, year.start = NA, year.end = NA,
  do_C4vars = FALSE, do_Cheatgrass_ClimVars = FALSE, simTime2 = NULL,
  latitude = 90) {

  x <- dbW_weatherData_to_dataframe(weatherList)

  # Trim to requested years
  if (!is.na(year.start)) {
    x <- x[x[, "Year"] >= year.start, ]
  } else {
    year.start <- x[1, "Year"]
  }

  if (!is.na(year.end)) {
    x <- x[x[, "Year"] <= year.end, ]
  } else {
    year.end <- x[nrow(x), "Year"]
  }

  years <- unique(x[, "Year"])

  if (length(years) == 0) {
    stop("'calc_SiteClimate': no weather data available for ",
      "requested range of years")
  }

  # Mean daily temperature
  Tmean_C <- rowMeans(x[, c("Tmax_C", "Tmin_C")])

  # Get time sequence information
  is_simTime2_good <- !is.null(simTime2) &&
    identical(years, simTime2[["useyrs_NSadj"]]) &&
    !is.null(simTime2[["month_ForEachUsedDay"]])

  is_simTime2_good_for_C4vars <- if (do_C4vars) {
      if (is_simTime2_good) {
        !is.null(simTime2[["month_ForEachUsedDay_NSadj"]]) &&
        !is.null(simTime2[["year_ForEachUsedDay_NSadj"]])
      } else FALSE
    } else TRUE

  if (is_simTime2_good && is_simTime2_good_for_C4vars) {
    st2 <- simTime2
  } else {
    st2 <- rSW2data::simTiming_ForEachUsedTimeUnit(
      useyrs = years,
      sim_tscales = "daily",
      latitude = latitude,
      account_NorthSouth = do_C4vars
    )
  }


  # Calculate monthly values
  index <- st2[["month_ForEachUsedDay"]] + 100 * x[, "Year"]

  mon_Temp <- vapply(
    list(Tmean_C, x[, "Tmin_C"], x[, "Tmax_C"]),
    function(data) matrix(tapply(data, index, mean, na.rm = TRUE), nrow = 12),
    FUN.VALUE = matrix(NA_real_, nrow = 12, ncol = length(years))
  )

  mon_PPT <- matrix(tapply(x[, "PPT_cm"], index, sum, na.rm = TRUE), nrow = 12)

  list(
    # Calculate mean monthly values
    meanMonthlyTempC = apply(mon_Temp[, , 1, drop = FALSE], 1, mean,
      na.rm = TRUE),
    minMonthlyTempC = apply(mon_Temp[, , 2, drop = FALSE], 1, mean,
      na.rm = TRUE),
    maxMonthlyTempC = apply(mon_Temp[, , 3, drop = FALSE], 1, mean,
      na.rm = TRUE),
    meanMonthlyPPTcm = apply(mon_PPT, 1, mean, na.rm = TRUE),

    # Calculate mean annual values
    MAP_cm = sum(mon_PPT, na.rm = TRUE) / length(years),
    MAT_C = mean(Tmean_C, na.rm = TRUE),

    # If C4-variables are requested
    dailyTempMin = if (do_C4vars) x[, "Tmin_C"] else NA,
    dailyTempMean = if (do_C4vars) Tmean_C else NA,
    dailyC4vars = if (do_C4vars) {
      sw_dailyC4_TempVar(dailyTempMin = x[, "Tmin_C"], dailyTempMean = Tmean_C,
        simTime2 = st2)
      } else NA,

    # If cheatgrass-variables are requested
    Cheatgrass_ClimVars = if (do_Cheatgrass_ClimVars) {
      sw_Cheatgrass_ClimVar(
        monthlyPPT_cm = mon_PPT,
        monthlyTempMean_C = mon_Temp[, , 1, drop = FALSE],
        monthlyTempMin_C = mon_Temp[, , 2, drop = FALSE]
      )
    } else NA
  )
}


#' \var{Look-up} yearly atmospheric CO2 concentration values
#'
#' @param start An integer value. First year for which to \var{look-up} values.
#' @param end An integer value. Last year for which to \var{look-up} values.
#' @param name_co2 A character string. The (partial) name of the CO2 series,
#'   i.e., a column name of \code{tr_CO2a}. See details.
#' @param tr_CO2a A numeric \code{data.frame} with the CO2 values [ppm].
#'   Default values are taken from \code{\link{sw2_tr_CO2a}}.
#'
#' @section Details: \code{name_co2} may contain multiple data set names,
#'   either as vector of strings, or as names separated by "|".
#'   Values of the first match are used;
#'   any missing values are filled in from the second matching column,
#'   and so forth.
#'
#' @seealso \code{\link{sw2_tr_CO2a}} for description of data
#'
#' @examples
#' lookup_annual_CO2a(start = 1765, end = 2300, name_co2 = "RCP45")
#' lookup_annual_CO2a(start = 1765, end = 2300, name_co2 = "CMIP5_RCP45")
#' lookup_annual_CO2a(start = 1980, end = 2005, name_co2 = "CMIP5_historical")
#' lookup_annual_CO2a(
#'   start = 1980,
#'   end = 2021,
#'   name_co2 = c("CMIP6_historical", "CMIP6_SSP119")
#' )
#' lookup_annual_CO2a(
#'   start = 1980,
#'   end = 2021,
#'   name_co2 = "CMIP6_historical|CMIP6_SSP119"
#' )
#'
#' \dontrun{
#' ## This fails because "CMIP5_historical" has no values after 2005
#' lookup_annual_CO2a(start = 1980, end = 2020, name_co2 = "CMIP5_historical")
#' }
#'
#' @export
lookup_annual_CO2a <- function(
  start,
  end,
  name_co2,
  tr_CO2a = rSOILWAT2::sw2_tr_CO2a
) {
  # Locate scenario
  name_co2 <- paste0(name_co2, collapse = "|")
  scenario_index <- grep(name_co2, colnames(tr_CO2a), ignore.case = TRUE)
  n_sc <- length(scenario_index)

  # Locate years
  ids_years <- match(start:end, tr_CO2a[, "Year"], nomatch = NA)


  if (n_sc > 0 && length(ids_years) > 0 && !anyNA(ids_years)) {
    # Extract values
    x <- tr_CO2a[ids_years, scenario_index]

    if (n_sc > 1) {
      # Take values from first match; if NA, then from second match, etc.
      tmp <- rep(NA, length(ids_years))
      for (k in seq_len(n_sc)) {
        if (!anyNA(tmp)) break
        ids <- is.na(tmp)
        tmp[ids] <- x[ids, k]
      }
      x <- tmp
    }

    scenarioCO2_ppm <- cbind(
      Year = tr_CO2a[ids_years, "Year"],
      CO2ppm = as.numeric(x)
    )

    # Check for missing values
    if (anyNA(scenarioCO2_ppm)) {
      stop(
        "Some requested years have no CO2 values for scenario(s) ",
        shQuote(name_co2)
      )
    }

  } else {
    stop("Lookup of CO2 failed.")
  }

  scenarioCO2_ppm
}
