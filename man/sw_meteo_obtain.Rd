% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/sw_WeatherExtract.R
\name{sw_meteo_obtain}
\alias{sw_meteo_obtain}
\alias{sw_meteo_obtain_DayMet}
\alias{sw_meteo_obtain_SCAN}
\title{Extract meteorological data from external source and format for \code{rSOILWAT2}}
\usage{
sw_meteo_obtain_DayMet(x, start_year, end_year, rawdata = NULL, ...)

sw_meteo_obtain_SCAN(x, start_year, end_year, rawdata = NULL, ...)
}
\arguments{
\item{x}{Identifying information for the station/location for which
meteorological data is requested, see details.}

\item{start_year}{A integer value. The first calendar year of the simulation.}

\item{end_year}{A integer value. The last calendar year of the simulation.}

\item{rawdata}{A data object retrieved previously.}

\item{...}{Additional arguments are ignored.}
}
\value{
A list with the following elements
\itemize{
\item \code{"metadata"}: site metadata (if available)
\item \code{"rawdata"}: data as downloaded (or argument \code{rawdata} if provided)
\item \code{"weatherDF"}: data frame with weather data formatted for \code{rSOILWAT2}
\item \code{"vals_missing"}: logical matrix indicating which weather values in
\code{"weatherDF"} are missing
\item \code{"desc_rsds"}: solar radiation descriptor (if available)
\item \code{"use_cloudCoverMonthly"}: flag indicating need for monthly cloud cover
\item \code{"use_windSpeedMonthly"}: flag indicating need for monthly wind speed
\item \code{"use_humidityMonthly"}: flag indicating need for monthly humidity
\item \code{"dailyInputFlags"}: logical vector indicating which weather variables
contain at least some values (see \code{\link[=calc_dailyInputFlags]{calc_dailyInputFlags()}})
}
}
\description{
Extract meteorological data from external source and format for \code{rSOILWAT2}
}
\section{Details}{

\code{sw_meteo_obtain_DayMet()} uses data from
\href{https://daymet.ornl.gov/single-pixel/}{\verb{DayMet ORNL DAAC}}
via \code{\link[daymetr:download_daymet]{daymetr::download_daymet()}}.
The argument \code{x} is a named vector with \code{"longitude"} and \code{"latitude"} in
decimal degrees.
\code{"DayMet"} uses a \code{"noleap"} (\code{"365_day"}) calendar which is converted
to a \code{"standard"} calendar (i.e., one with leap days); this results in
missing values on inserted leap days (see code example).
\code{"DayMet"} does not contain wind speed which is a required input.


\code{sw_meteo_obtain_SCAN()} uses data from
\href{https://www.nrcs.usda.gov/resources/data-and-reports/soil-climate-analysis-network}{\code{USDA-NRCS} \code{SCAN/SNOTEL} stations}
via \code{\link[soilDB:fetchSCAN]{soilDB::fetchSCAN()}}.
The argument \code{x} takes a \code{NRCS} \code{SCAN/SNOTEL} station code.
}

\examples{
## Example: Daymet weather for "Mccracken Mesa" location
##   (see `mm_scan[["metadata"]]`)
mm_dm <- if (requireNamespace("curl") && curl::has_internet()) {
  try(
    rSOILWAT2::sw_meteo_obtain_DayMet(
      x = c(longitude = -109.3378, latitude = 37.44671),
      start_year = 2015,
      end_year = 2023
    )
  )
}

if (!is.null(mm_dm) && !inherits(mm_dm, "try-error")) {
  # Fill in missing values on leap days
  mm_dm_wdata <- rSOILWAT2::dbW_fixWeather(mm_dm[["weatherDF"]])

  # Prepare a SOILWAT2 simulation
  swin <- rSOILWAT2::sw_exampleData
  rSOILWAT2::swYears_EndYear(swin) <- 2023
  rSOILWAT2::swYears_StartYear(swin) <- 2015
  swin@weather@desc_rsds <- mm_dm[["desc_rsds"]]
  swin@weather@use_cloudCoverMonthly <- mm_dm[["use_cloudCoverMonthly"]]
  swin@weather@use_windSpeedMonthly <- mm_dm[["use_windSpeedMonthly"]]
  swin@weather@use_humidityMonthly <- mm_dm[["use_humidityMonthly"]]
  swin@weather@dailyInputFlags <- mm_dm[["dailyInputFlags"]]

  # Set mean monthly climate values to missing
  # (except wind speed which is missing in DayMet)
  rSOILWAT2::swCloud_Humidity(swin)[] <- NA_real_
  rSOILWAT2::swCloud_WindSpeed(swin)[] <- rep(1.5, times = 12L)
  rSOILWAT2::swCloud_SkyCover(swin)[] <- NA_real_

  # Obtain atmospheric CO2 concentration (including for vegetation reference)
  rSOILWAT2::swCarbon_Scenario(swin) <- "CMIP6_historical|CMIP6_SSP119"
  rSOILWAT2::swCarbon_CO2ppm(swin) <- rSOILWAT2::lookup_annual_CO2a(
    start = min(swin@prod2@vegYear, 2015),
    end = 2023,
    name_co2 = rSOILWAT2::swCarbon_Scenario(swin)
  )

  # Run simulation (after providing remaining inputs, e.g., soils)
  swout <- try(
    rSOILWAT2::sw_exec(
      inputData = swin,
      weatherList = mm_dm_wdata[["weatherData"]],
      quiet = TRUE
    ),
    silent = TRUE
  )
}

## Example: SCAN station "Mccracken Mesa"
mm_scan <- if (requireNamespace("curl") && curl::has_internet()) {
  try(
    rSOILWAT2::sw_meteo_obtain_SCAN(
      x = 2140, # SCAN station code
      start_year = 2015,
      end_year = 2023
    )
  )
}

if (
  !is.null(mm_scan) && !inherits(mm_scan, "try-error") &&
  !is.null(mm_dm) && !inherits(mm_dm, "try-error") &&
  requireNamespace("graphics")
) {
  vars <- c("Tmax_C", "Tmin_C", "PPT_cm")
  par_prev <- graphics::par(mfrow = grDevices::n2mfrow(length(vars)))

  for (k in seq_along(vars)) {
    graphics::plot(
      x = mm_scan[["weatherDF"]][[vars[[k]]]],
      y = mm_dm[["weatherDF"]][[vars[[k]]]],
      xlab = paste("SCAN", vars[[k]]),
      ylab = paste("DayMet", vars[[k]])
    )
    graphics::abline(a = 0, b = 1, col = "red")
  }

  graphics::par(par_prev)
  unlink("Rplots.*") # clean up
}

}
